{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Spatial Computing Project Template This is a project template for Spatial Computing Students. Students shall fork this repository and use it as the basis of their project. Mid-term and Final submission is expected through pull GitHub.","title":"Home"},{"location":"#spatial-computing-project-template","text":"This is a project template for Spatial Computing Students. Students shall fork this repository and use it as the basis of their project. Mid-term and Final submission is expected through pull GitHub.","title":"Spatial Computing Project Template"},{"location":"about/","text":"About Include your name, the tutors names, and the course name here","title":"About"},{"location":"about/#about","text":"Include your name, the tutors names, and the course name here","title":"About"},{"location":"A1_Planning/Process/","text":"Planning Design Goal In this project the challenge is to design a housing complex incorporating several communal/public facilities for a cooperative live-work-play association. A group of graduate students and young professionals have formed this cooperative to make their own live-work-play space. The housing complex is to accommodate students, young graduates (starters), and assisted living. The complex also provides communal/public facilities, almost as a collective. Urban Analysis Before we specify the conditions of our project on the building scale we did a short analysis of the urban context through which we came to six important topics that we will discuss here. Sequences Sequences with entrances Sequences with network","title":"Process"},{"location":"A1_Planning/Process/#planning","text":"","title":"Planning"},{"location":"A1_Planning/Process/#design-goal","text":"In this project the challenge is to design a housing complex incorporating several communal/public facilities for a cooperative live-work-play association. A group of graduate students and young professionals have formed this cooperative to make their own live-work-play space. The housing complex is to accommodate students, young graduates (starters), and assisted living. The complex also provides communal/public facilities, almost as a collective.","title":"Design Goal"},{"location":"A1_Planning/Process/#urban-analysis","text":"Before we specify the conditions of our project on the building scale we did a short analysis of the urban context through which we came to six important topics that we will discuss here.","title":"Urban Analysis"},{"location":"A1_Planning/Process/#sequences","text":"","title":"Sequences"},{"location":"A1_Planning/Process/#sequences-with-entrances","text":"","title":"Sequences with entrances"},{"location":"A1_Planning/Process/#sequences-with-network","text":"","title":"Sequences with network"},{"location":"A1_Planning/Products/","text":"Planning Bubble Diagram Metro Network","title":"Product"},{"location":"A1_Planning/Products/#planning","text":"","title":"Planning"},{"location":"A1_Planning/Products/#bubble-diagram","text":"","title":"Bubble Diagram"},{"location":"A1_Planning/Products/#metro-network","text":"","title":"Metro Network"},{"location":"A2_Configuring/Process/","text":"Configuring Program of requirements Area m\u00b2 and explanation Student housing 30 m\u00b2 times 80 units = 2400 m\u00b2 - Small private kitchen - Small private living room - Private bathroom - Common areas such as co-cooking and the community center. Assisted living 35 m\u00b2 times 30 units = 1050 m\u00b2 - Small private kitchen - Small private living room - Private bathroom - Common areas such as co-cooking and the community center. Starter housing 75 m\u00b2 times 100 units = 7500 m\u00b2 - bedroom, bathroom, livingroom, kitchen, extra bedroom/ study room Restaurant 80 places to sit = 104 m\u00b2 (= 60% of total area) The kitchen is 70 m\u00b2 (= 40% of total area) Total of 180 m\u00b2 Shop Supermarket 800 m\u00b2 Co-cooking Next to the common area, 100 m\u00b2 Atrium/ community center 200 m\u00b2. A place just for the residents, where people can meet their neighbours. Important is that there are different spaces from more private to more public. ![title](../img/atrium.png) Pub 180 m\u00b2. 80 places to sit (same as the restaurant) Gym 220 m\u00b2. Mostly used by residents Arcade 400 m\u00b2 Cinematheque 120 visitors. The seating are is 120 m\u00b2, the walking area \u00b1 80 m\u00b2 Total of 200 m\u00b2 Offices Shared offices are 18,5 m\u00b2. There will be room for 50 employees, so 25 shared offices = 460 m\u00b2 Co-work spaces Work group areas of 7,5 m\u00b2 per employee. Place for 100 employees = 750 m\u00b2 Library 200 m\u00b2 Fablab 150 m\u00b2 Parking Minimum of 105 parking places times 12,5 m\u00b2. The total area, including the walking area = 2500 m\u00b2 Flowchart Now that we have a program we can start thinking of the analyses we want to do for the building. We came up with six different analyses. Matrix of connections Before we dived into the analyses with python, we first wanted to visualize the mapping of the relations between relation. We did this in several subdivisions with each there own main focus. These different themes are shown below. Sun acces Public Entrance acces Green access Noise repel Voxel Size After we developped a clear notice of our wants for the building, we were able to start thinking of a proper voxel size. For this we started on the micro scale namely the stairs. Riser-Thread 2x Riser 1x Thread Ratio Common Denominator Voxel Size 180mm x 240mm (2 x 180) + (1 x 240) = 610 3:4 6 900x900 mm 1800x1800 mm 3600x3600 mm Building Envelope Now that we have a specified voxel size, we are able to voxelize our envelope. We have chosen to make the existing building mass with the football field in between available as a new envelope. To keep as much greenery as possible, the park behind the building will be retain.","title":"Process"},{"location":"A2_Configuring/Process/#configuring","text":"","title":"Configuring"},{"location":"A2_Configuring/Process/#program-of-requirements","text":"Area m\u00b2 and explanation Student housing 30 m\u00b2 times 80 units = 2400 m\u00b2 - Small private kitchen - Small private living room - Private bathroom - Common areas such as co-cooking and the community center. Assisted living 35 m\u00b2 times 30 units = 1050 m\u00b2 - Small private kitchen - Small private living room - Private bathroom - Common areas such as co-cooking and the community center. Starter housing 75 m\u00b2 times 100 units = 7500 m\u00b2 - bedroom, bathroom, livingroom, kitchen, extra bedroom/ study room Restaurant 80 places to sit = 104 m\u00b2 (= 60% of total area) The kitchen is 70 m\u00b2 (= 40% of total area) Total of 180 m\u00b2 Shop Supermarket 800 m\u00b2 Co-cooking Next to the common area, 100 m\u00b2 Atrium/ community center 200 m\u00b2. A place just for the residents, where people can meet their neighbours. Important is that there are different spaces from more private to more public. ![title](../img/atrium.png) Pub 180 m\u00b2. 80 places to sit (same as the restaurant) Gym 220 m\u00b2. Mostly used by residents Arcade 400 m\u00b2 Cinematheque 120 visitors. The seating are is 120 m\u00b2, the walking area \u00b1 80 m\u00b2 Total of 200 m\u00b2 Offices Shared offices are 18,5 m\u00b2. There will be room for 50 employees, so 25 shared offices = 460 m\u00b2 Co-work spaces Work group areas of 7,5 m\u00b2 per employee. Place for 100 employees = 750 m\u00b2 Library 200 m\u00b2 Fablab 150 m\u00b2 Parking Minimum of 105 parking places times 12,5 m\u00b2. The total area, including the walking area = 2500 m\u00b2","title":"Program of requirements"},{"location":"A2_Configuring/Process/#flowchart","text":"Now that we have a program we can start thinking of the analyses we want to do for the building. We came up with six different analyses.","title":"Flowchart"},{"location":"A2_Configuring/Process/#matrix-of-connections","text":"Before we dived into the analyses with python, we first wanted to visualize the mapping of the relations between relation. We did this in several subdivisions with each there own main focus. These different themes are shown below.","title":"Matrix of connections"},{"location":"A2_Configuring/Process/#sun-acces","text":"","title":"Sun acces"},{"location":"A2_Configuring/Process/#public-entrance-acces","text":"","title":"Public Entrance acces"},{"location":"A2_Configuring/Process/#green-access","text":"","title":"Green access"},{"location":"A2_Configuring/Process/#noise-repel","text":"","title":"Noise repel"},{"location":"A2_Configuring/Process/#voxel-size","text":"After we developped a clear notice of our wants for the building, we were able to start thinking of a proper voxel size. For this we started on the micro scale namely the stairs. Riser-Thread 2x Riser 1x Thread Ratio Common Denominator Voxel Size 180mm x 240mm (2 x 180) + (1 x 240) = 610 3:4 6 900x900 mm 1800x1800 mm 3600x3600 mm","title":"Voxel Size"},{"location":"A2_Configuring/Process/#building-envelope","text":"Now that we have a specified voxel size, we are able to voxelize our envelope. We have chosen to make the existing building mass with the football field in between available as a new envelope. To keep as much greenery as possible, the park behind the building will be retain.","title":"Building Envelope"},{"location":"A2_Configuring/Products/","text":"Configuring Program of requirements moet nog scherper Matrix met connecties erbij Rel Chart and KPI","title":"Product"},{"location":"A2_Configuring/Products/#configuring","text":"","title":"Configuring"},{"location":"A2_Configuring/Products/#program-of-requirements","text":"moet nog scherper Matrix met connecties erbij","title":"Program of requirements"},{"location":"A2_Configuring/Products/#rel-chart-and-kpi","text":"","title":"Rel Chart and KPI"},{"location":"A3_Massing/Products/","text":"","title":"Product"},{"location":"A3_Massing/Process/Green%20analysis/Green%20analysis/","text":"Green Analysis In this analysis we wanted to create some attraction to green spaces in the direct neighborhood of the envelope. The eventual goal is to minimize the graph distance of a voxel which is in need of green space, and the green space its self. To accomplish this we used the notebook offered by Shervin Azadi. Park The first green space we defined is the small park between the Almondestraat and the Schoterbosstraat. We did this by extracting the index number 422, which represents the park, from the distance matrix. # select the corresponding row in the matrix park_dist = dist_mtrx [ 422 ] # find the maximum valid value max_valid = np . ma . masked_invalid ( park_dist ) . max () # set the infinities to one more than the maximum valid values park_dist [ park_dist == np . inf ] = max_valid + 1 Raingarden The same process we repeated for the second green space which is the Raingarden on the south east side of the envelope. # select the corresponding row in the matrix park_dist = dist_mtrx [ 506 ] # find the maximum valid value max_valid = np . ma . masked_invalid ( park_dist ) . max () # set the infinities to one more than the maximum valid values park_dist [ park_dist == np . inf ] = max_valid + 1 Hofbogen For the third green space The Hofbogen, we adjusted the code a little bit since we wanted to select a complete row of voxels. 1.3 Select Hofbogen Voxels p = pv . Plotter ( notebook = True ) # initialize the selection lattice base_lattice = avail_lattice * 0 - 1 # init base flat base_flat = base_lattice . flatten () . astype ( int ) # Set the grid dimensions: shape + 1 because we want to inject our values on the CELL data grid = pv . UniformGrid () grid . dimensions = np . array ( base_lattice . shape ) + 1 # The bottom left corner of the data set grid . origin = base_lattice . minbound - base_lattice . unit * 0.5 # These are the cell sizes along each axis grid . spacing = base_lattice . unit # adding the boundingbox wireframe p . add_mesh ( grid . outline (), color = \"grey\" , label = \"Domain\" ) # adding the avilability lattice init_avail_lattice . fast_vis ( p ) # adding axes p . add_axes () p . show_bounds ( grid = \"back\" , location = \"back\" , color = \"#aaaaaa\" ) def create_mesh ( value ): i = int ( value ) # init base flat base_copy = np . copy ( base_lattice ) base_copy = base_copy * 0 - 1 base_copy [:, i , 1 ] = 0 base_new = base_copy # base_flat = base_lattice.flatten().astype(int) # base_flat = base_flat * 0 - 1 # base_flat[i] = 0 # base_new = base_flat.reshape(base_lattice.shape) # Add the data values to the cell data grid . cell_arrays [ \"Selection\" ] = base_copy . flatten ( order = \"F\" ) . astype ( int ) # Flatten the array! # filtering the voxels threshed = grid . threshold ([ - 0.1 , 0.9 ]) # adding the voxels p . add_mesh ( threshed , name = 'sphere' , show_edges = True , opacity = 1.0 , show_scalar_bar = False ) return p . add_slider_widget ( create_mesh , [ 0 , base_lattice . shape [ 1 ]], title = '1D Index' , value = 0 , event_type = \"always\" , style = \"classic\" , pointa = ( 0.1 , 0.1 ), pointb = ( 0.9 , 0.1 )) p . show ( use_ipyvtk = True ) 1.4 Construct Distance to Hogbogen Lattice base_lattice = avail_lattice * 0 # voxel selection base_lattice [:, 0 , 1 ] = 1 base_flat = base_lattice . flatten () vox_interest = np . where ( base_flat == 1 ) print ( vox_interest ) # print(dist_mtrx[[51,682]]) # [dist_mtrx[51], dist_mtrx[682]] dist_interest = dist_mtrx [ vox_interest ] 1.4 Construct Distance to Hogbogen Lattice # find the maximum valid value max_valid = np . ma . masked_invalid ( dist_interest ) . max () # set the infinities to one more than the maximum valid values dist_interest [ dist_interest == np . inf ] = max_valid + 1 min_dist = np . min ( dist_interest , axis = 0 )","title":"Green analysis"},{"location":"A3_Massing/Process/Green%20analysis/Green%20analysis/#green-analysis","text":"In this analysis we wanted to create some attraction to green spaces in the direct neighborhood of the envelope. The eventual goal is to minimize the graph distance of a voxel which is in need of green space, and the green space its self. To accomplish this we used the notebook offered by Shervin Azadi.","title":"Green Analysis"},{"location":"A3_Massing/Process/Green%20analysis/Green%20analysis/#park","text":"The first green space we defined is the small park between the Almondestraat and the Schoterbosstraat. We did this by extracting the index number 422, which represents the park, from the distance matrix. # select the corresponding row in the matrix park_dist = dist_mtrx [ 422 ] # find the maximum valid value max_valid = np . ma . masked_invalid ( park_dist ) . max () # set the infinities to one more than the maximum valid values park_dist [ park_dist == np . inf ] = max_valid + 1","title":"Park"},{"location":"A3_Massing/Process/Green%20analysis/Green%20analysis/#raingarden","text":"The same process we repeated for the second green space which is the Raingarden on the south east side of the envelope. # select the corresponding row in the matrix park_dist = dist_mtrx [ 506 ] # find the maximum valid value max_valid = np . ma . masked_invalid ( park_dist ) . max () # set the infinities to one more than the maximum valid values park_dist [ park_dist == np . inf ] = max_valid + 1","title":"Raingarden"},{"location":"A3_Massing/Process/Green%20analysis/Green%20analysis/#hofbogen","text":"For the third green space The Hofbogen, we adjusted the code a little bit since we wanted to select a complete row of voxels. 1.3 Select Hofbogen Voxels p = pv . Plotter ( notebook = True ) # initialize the selection lattice base_lattice = avail_lattice * 0 - 1 # init base flat base_flat = base_lattice . flatten () . astype ( int ) # Set the grid dimensions: shape + 1 because we want to inject our values on the CELL data grid = pv . UniformGrid () grid . dimensions = np . array ( base_lattice . shape ) + 1 # The bottom left corner of the data set grid . origin = base_lattice . minbound - base_lattice . unit * 0.5 # These are the cell sizes along each axis grid . spacing = base_lattice . unit # adding the boundingbox wireframe p . add_mesh ( grid . outline (), color = \"grey\" , label = \"Domain\" ) # adding the avilability lattice init_avail_lattice . fast_vis ( p ) # adding axes p . add_axes () p . show_bounds ( grid = \"back\" , location = \"back\" , color = \"#aaaaaa\" ) def create_mesh ( value ): i = int ( value ) # init base flat base_copy = np . copy ( base_lattice ) base_copy = base_copy * 0 - 1 base_copy [:, i , 1 ] = 0 base_new = base_copy # base_flat = base_lattice.flatten().astype(int) # base_flat = base_flat * 0 - 1 # base_flat[i] = 0 # base_new = base_flat.reshape(base_lattice.shape) # Add the data values to the cell data grid . cell_arrays [ \"Selection\" ] = base_copy . flatten ( order = \"F\" ) . astype ( int ) # Flatten the array! # filtering the voxels threshed = grid . threshold ([ - 0.1 , 0.9 ]) # adding the voxels p . add_mesh ( threshed , name = 'sphere' , show_edges = True , opacity = 1.0 , show_scalar_bar = False ) return p . add_slider_widget ( create_mesh , [ 0 , base_lattice . shape [ 1 ]], title = '1D Index' , value = 0 , event_type = \"always\" , style = \"classic\" , pointa = ( 0.1 , 0.1 ), pointb = ( 0.9 , 0.1 )) p . show ( use_ipyvtk = True ) 1.4 Construct Distance to Hogbogen Lattice base_lattice = avail_lattice * 0 # voxel selection base_lattice [:, 0 , 1 ] = 1 base_flat = base_lattice . flatten () vox_interest = np . where ( base_flat == 1 ) print ( vox_interest ) # print(dist_mtrx[[51,682]]) # [dist_mtrx[51], dist_mtrx[682]] dist_interest = dist_mtrx [ vox_interest ] 1.4 Construct Distance to Hogbogen Lattice # find the maximum valid value max_valid = np . ma . masked_invalid ( dist_interest ) . max () # set the infinities to one more than the maximum valid values dist_interest [ dist_interest == np . inf ] = max_valid + 1 min_dist = np . min ( dist_interest , axis = 0 )","title":"Hofbogen"},{"location":"A3_Massing/Process/Noise%20Analysis/Noise%20analysis/","text":"","title":"Noise analysis"},{"location":"A3_Massing/Process/Public%20entrance%20analysis/Public%20entrance%20analysis/","text":"","title":"Public entrance analysis"},{"location":"A3_Massing/Process/Shadow%20analysis/Shadow%20analysis/","text":"Shadow analysis After removing the voxels with too little sun access, we have analysed the shadow casting of the new envelope. A part of the building envelope would provide shade for the surroundings. Because the building has a high height and is close to other buildings, we have removed the voxels that have a major influence on the shadow on certain parts of the immediate context. Just like in the sun analysis, we compute many intersections. This time, however, we are computing them from the sky towards the voxels. In the code, the directions of the sun vectors are opposite to those in the sun analysis. # constructing the sun direction from the sun vectors in a numpy array sun_dirs = np . array ( sun_vectors ) # exract the centroids of the envelope voxels vox_cens = full_lattice . centroids ray_dir = [] ray_src = [] for v_cen in vox_cens : for s_dir in sun_dirs : ray_dir . append ( s_dir ) ray_src . append ( v_cen ) # converting the list of directions and sources to numpy array ray_dir = np . array ( ray_dir ) ray_src = np . array ( ray_src ) Because we want to keep the park behind the building, we also think it is important that this remains a nice green place. That is why we have taken this into account in our analysis. we have changed the immediate context In Rhino and placed a building with a height of 1.75 meters (human height) on the park. You can clearly see the difference in the colors, and so in the shadow casting of the envelope. Without park With park We have removed the voxels that have over 45 percent of intersections by generating an envelope based on the selection. # 7.2. Generating an envelope based on the selection lower_bound = 0.01 upper_bound = 0.45 lower_condition = shadow_casting_lattice > lower_bound upper_condition = shadow_casting_lattice < upper_bound new_avail_lattice = lower_condition * upper_condition We continue the next analysis with the newly created envelope. New envelope","title":"Shadow analysis"},{"location":"A3_Massing/Process/Shadow%20analysis/Shadow%20analysis/#shadow-analysis","text":"After removing the voxels with too little sun access, we have analysed the shadow casting of the new envelope. A part of the building envelope would provide shade for the surroundings. Because the building has a high height and is close to other buildings, we have removed the voxels that have a major influence on the shadow on certain parts of the immediate context. Just like in the sun analysis, we compute many intersections. This time, however, we are computing them from the sky towards the voxels. In the code, the directions of the sun vectors are opposite to those in the sun analysis. # constructing the sun direction from the sun vectors in a numpy array sun_dirs = np . array ( sun_vectors ) # exract the centroids of the envelope voxels vox_cens = full_lattice . centroids ray_dir = [] ray_src = [] for v_cen in vox_cens : for s_dir in sun_dirs : ray_dir . append ( s_dir ) ray_src . append ( v_cen ) # converting the list of directions and sources to numpy array ray_dir = np . array ( ray_dir ) ray_src = np . array ( ray_src ) Because we want to keep the park behind the building, we also think it is important that this remains a nice green place. That is why we have taken this into account in our analysis. we have changed the immediate context In Rhino and placed a building with a height of 1.75 meters (human height) on the park. You can clearly see the difference in the colors, and so in the shadow casting of the envelope. Without park With park We have removed the voxels that have over 45 percent of intersections by generating an envelope based on the selection. # 7.2. Generating an envelope based on the selection lower_bound = 0.01 upper_bound = 0.45 lower_condition = shadow_casting_lattice > lower_bound upper_condition = shadow_casting_lattice < upper_bound new_avail_lattice = lower_condition * upper_condition We continue the next analysis with the newly created envelope. New envelope","title":"Shadow analysis"},{"location":"A3_Massing/Process/Sun%20analysis/Sun%20analysis/","text":"Sun analysis With the sun analysis we first wanted to gain insight into the sunny and not sunny places of the building. This analysis of the sun acces on each part of the building is usefull when placing different agents in an optimal place. With the computed sun rays and the given context mesh we have computed the intersection between them. When an intersection is found, the calculated voxel does not fully see the sun and thus, has a low percentage of sun access. We wanted our building to stay on the ground and not remove all of the lower voxels to keep a good connection between the shops and the hofbogen. For this reason, we have removed the voxels that have less than 55 percent of access to the sun. Sun access before removing voxels Sun access after the voxels have been removed","title":"Sun analysis"},{"location":"A3_Massing/Process/Sun%20analysis/Sun%20analysis/#sun-analysis","text":"With the sun analysis we first wanted to gain insight into the sunny and not sunny places of the building. This analysis of the sun acces on each part of the building is usefull when placing different agents in an optimal place. With the computed sun rays and the given context mesh we have computed the intersection between them. When an intersection is found, the calculated voxel does not fully see the sun and thus, has a low percentage of sun access. We wanted our building to stay on the ground and not remove all of the lower voxels to keep a good connection between the shops and the hofbogen. For this reason, we have removed the voxels that have less than 55 percent of access to the sun. Sun access before removing voxels Sun access after the voxels have been removed","title":"Sun analysis"},{"location":"A3_Massing/Process/Visibility%20analysis/Visibility%20analysis/","text":"Visibility analysis One of our starting points is to create a building that makes different connections. By this we mean connections between the various surrounding neighborhoods, between the greenery and connections inside of the building. The building should therefore not serve as a wall, but more as a passage. That is why we think it is important that for people passing by, there is a good view of the sky and the surroundings. For this, we have calculated the sky view factor and, just like in the previous analysis, removed the unnecessary voxels. Other than in the sun and shadow analysis we needed to compute the sky vectors. # Compute the sky vectors sphere_mesh = tm . creation . icosphere ( subdivisions = 3 , radius = 1.0 , color = None ) sphere_vectors = np . copy ( sphere_mesh . vertices ) sky_vectors = [] for v in sphere_vectors : if v [ 2 ] > 0.0 : sky_vectors . append ( v ) sky_vectors = np . array ( sky_vectors ) print ( sky_vectors . shape ) Then we have computed the intersections between the sky rays and the context. The context exists only of the street around the building. This is because we only need to check if people walking by can not see the sky because of the building we are making. The other context can be left out. We have done the calculation on the envelope on the envelope that remained after the sun and shadow analysis. Visibility analysis Final envelope","title":"Visibility analysis"},{"location":"A3_Massing/Process/Visibility%20analysis/Visibility%20analysis/#visibility-analysis","text":"One of our starting points is to create a building that makes different connections. By this we mean connections between the various surrounding neighborhoods, between the greenery and connections inside of the building. The building should therefore not serve as a wall, but more as a passage. That is why we think it is important that for people passing by, there is a good view of the sky and the surroundings. For this, we have calculated the sky view factor and, just like in the previous analysis, removed the unnecessary voxels. Other than in the sun and shadow analysis we needed to compute the sky vectors. # Compute the sky vectors sphere_mesh = tm . creation . icosphere ( subdivisions = 3 , radius = 1.0 , color = None ) sphere_vectors = np . copy ( sphere_mesh . vertices ) sky_vectors = [] for v in sphere_vectors : if v [ 2 ] > 0.0 : sky_vectors . append ( v ) sky_vectors = np . array ( sky_vectors ) print ( sky_vectors . shape ) Then we have computed the intersections between the sky rays and the context. The context exists only of the street around the building. This is because we only need to check if people walking by can not see the sky because of the building we are making. The other context can be left out. We have done the calculation on the envelope on the envelope that remained after the sun and shadow analysis. Visibility analysis Final envelope","title":"Visibility analysis"},{"location":"A4_Forming/Process/","text":"Forming Here you should include the process and product of your 4th activity: Forming Title Forming (process): Form (product) Objective Document the process and products and provide explanations to ensure reusability of materials. Procedure Finalize the plans and the forms of all functional units. Optionally, choose a way to alter the jaggedness of voxels in the final form by partially bringing in contrasting curvy shapes, for instance as a shell around the building, e.g. through smoothing, relaxation, iso-surfaces, or topological transformation.","title":"Process"},{"location":"A4_Forming/Process/#forming","text":"Here you should include the process and product of your 4th activity: Forming Title Forming (process): Form (product) Objective Document the process and products and provide explanations to ensure reusability of materials. Procedure Finalize the plans and the forms of all functional units. Optionally, choose a way to alter the jaggedness of voxels in the final form by partially bringing in contrasting curvy shapes, for instance as a shell around the building, e.g. through smoothing, relaxation, iso-surfaces, or topological transformation.","title":"Forming"},{"location":"A4_Forming/Products/","text":"Forming Here you should include the process and product of your 4th activity: Forming Title Forming (process): Form (product) Objective Document the process and products and provide explanations to ensure reusability of materials. Procedure Finalize the plans and the forms of all functional units. Optionally, choose a way to alter the jaggedness of voxels in the final form by partially bringing in contrasting curvy shapes, for instance as a shell around the building, e.g. through smoothing, relaxation, iso-surfaces, or topological transformation.","title":"Product"},{"location":"A4_Forming/Products/#forming","text":"Here you should include the process and product of your 4th activity: Forming Title Forming (process): Form (product) Objective Document the process and products and provide explanations to ensure reusability of materials. Procedure Finalize the plans and the forms of all functional units. Optionally, choose a way to alter the jaggedness of voxels in the final form by partially bringing in contrasting curvy shapes, for instance as a shell around the building, e.g. through smoothing, relaxation, iso-surfaces, or topological transformation.","title":"Forming"},{"location":"documenting/folder_structure/","text":"Folder Structure The folders in student projects should strictly follow the structure of the folders in this repository. The main folders are four assignment folder (corresponding to each assignment) and one folder for final deliverables of your project. In general, the process sub-folders include all the necessary code, notebook, files, and models that you have used to achieve the final product of that assignment. It also includes document that represent the process of the assignment such as flowcharts, diagrams and pseudo-codes. The product sub-folder sh Here is run down of the overall structure: A1_Planning Process Product A2_Configuring Process Product A3_Massing Process Product A4_Forming Process Product Final_Deliverables Here you will include all the final deliverables of your project. docs Here you will write and edit the source of your documentation in MarkDown . An example is included in the template to help you begin documenting your project. site you should leave this directory empty. It will be filled by automatic documentation generator MkDocs","title":"Folder Structure"},{"location":"documenting/folder_structure/#folder-structure","text":"The folders in student projects should strictly follow the structure of the folders in this repository. The main folders are four assignment folder (corresponding to each assignment) and one folder for final deliverables of your project. In general, the process sub-folders include all the necessary code, notebook, files, and models that you have used to achieve the final product of that assignment. It also includes document that represent the process of the assignment such as flowcharts, diagrams and pseudo-codes. The product sub-folder sh Here is run down of the overall structure: A1_Planning Process Product A2_Configuring Process Product A3_Massing Process Product A4_Forming Process Product Final_Deliverables Here you will include all the final deliverables of your project. docs Here you will write and edit the source of your documentation in MarkDown . An example is included in the template to help you begin documenting your project. site you should leave this directory empty. It will be filled by automatic documentation generator MkDocs","title":"Folder Structure"},{"location":"documenting/guidelines/","text":"Guidelines File Size : No file bigger than 50mb is recommended. No file bigger than 100mb is allowed. Folder Structure : Do not change the folder structure. You can sub-folders to the existing folders if you want but you shall not change the existing overall structure Duplicates : Do NOT include duplicates in your files. Naming Convention : Avoid using special characters or spaces in file and folder names. Instead, use \"_\" to separate words in the names. Geometric Models (.3dm, .obj, etc) should be compressed before being added to repository. Video and Animation files should not be included the repository. They should be uploaded to online video services (YouTube, Vimeo, etc). You should embed those video link in your documentation. (GIF files are allowed in your repo)","title":"Guidelines"},{"location":"documenting/guidelines/#guidelines","text":"File Size : No file bigger than 50mb is recommended. No file bigger than 100mb is allowed. Folder Structure : Do not change the folder structure. You can sub-folders to the existing folders if you want but you shall not change the existing overall structure Duplicates : Do NOT include duplicates in your files. Naming Convention : Avoid using special characters or spaces in file and folder names. Instead, use \"_\" to separate words in the names. Geometric Models (.3dm, .obj, etc) should be compressed before being added to repository. Video and Animation files should not be included the repository. They should be uploaded to online video services (YouTube, Vimeo, etc). You should embed those video link in your documentation. (GIF files are allowed in your repo)","title":"Guidelines"},{"location":"documenting/instructions/","text":"Documenting Instructions Installation Install Conda You can install Anaconda or Miniconda to install conda package manager (if you don't know the difference you should install anaconda). Create documentation environment Now we need to create the appropriate environment for documenting by installing all the necessary tools. To do so we have provided you an environment droplet, which is a recipe for a series of installations that create the aforementioned environment. For that, after directing to the root folder of this project where the environment droplet ( environment.yml ) is located, you need to run the following command: conda env create -f environment.yml Start Work on Documentation After finishing your work on documentation you need to shutdown the server and deactivate the environment. Activate the Environment Now that you have created the appropriate environment, you need to activate the environment to be able to work inside it. For that, as you are in the root folder of this project, you need to run the following command: conda activate spatial_computing_docs If the command line is now indicating the name of the environment in paranthesis, it means that the environment is activated. Similar to this ( spatial_computing_docs ) { your username } @ { your computer name } spatial_computing_project_template % Run the Local Server Now that the environment is activated, we need to run the local server to be able to see the result of changes in the local version of the documentation website. For that, run the following command: mkdocs serve After running this command, if the server has started to work successfully, you should see the following line in the command line: INFO - Serving on http://127.0.0.1:8000 This means that the server is accessible at http://127.0.0.1:8000 . If you open your browser and go this link you should see a local version of the site. Writing Your Documentation In the documenting process you need to head to the docs folder and edit the .md (markdown) files, since the website is build from these files. In the root of this project, you can edit the configurations of your project in mkdocs.yml file: Adding o removing pages Add markdown extensions . Some of the useful extensions: arithmatex for writing mathematics highlight for code highlighting Customizing the looks of your documentation Adding MkDocs Plugins , such as: mknotebooks for including python notebooks in the documentations Finish Work on Documentation Server Shut Down To shutdown the server, you need to press Ctrl + C in the command line. The following should appear in the command line: INFO - Shutting down... Deactivate Environment After shutting down your server the command line is back to the normal state and you can run commands again. To deactivate your environment you need to run the following command: conda deactivate Deployment of the Documentation Site Build and Deploy to deploy your documentation website, you need to run the following command in the root of this repository: mkdocs gh-deploy This command will create a new branch in your repository called gh-pages and build your site in it. It will then push the new branch to your remote repository automatically. It will also create a site folder in your root directory containing all of your site files. Since this folder is added .gitignore file, it won't be committed or pushed to the remote repository. Setup GitHub Pages For the first time, you need to configure the GitHub Pages service on your GitHub repository so it wil automatically build your documentation website whenever you deploy your site. To do this: Go to your repository setting, got GitHub Pages section, select gh-pages branch, select /(root) location, click on the save button. The setting page will refresh, and now if you go to the address that is provided at the GitHub Pages section, Wola, here is your documentation!","title":"Instructions"},{"location":"documenting/instructions/#documenting-instructions","text":"","title":"Documenting Instructions"},{"location":"documenting/instructions/#installation","text":"","title":"Installation"},{"location":"documenting/instructions/#install-conda","text":"You can install Anaconda or Miniconda to install conda package manager (if you don't know the difference you should install anaconda).","title":"Install Conda"},{"location":"documenting/instructions/#create-documentation-environment","text":"Now we need to create the appropriate environment for documenting by installing all the necessary tools. To do so we have provided you an environment droplet, which is a recipe for a series of installations that create the aforementioned environment. For that, after directing to the root folder of this project where the environment droplet ( environment.yml ) is located, you need to run the following command: conda env create -f environment.yml","title":"Create documentation environment"},{"location":"documenting/instructions/#start-work-on-documentation","text":"After finishing your work on documentation you need to shutdown the server and deactivate the environment.","title":"Start Work on Documentation"},{"location":"documenting/instructions/#activate-the-environment","text":"Now that you have created the appropriate environment, you need to activate the environment to be able to work inside it. For that, as you are in the root folder of this project, you need to run the following command: conda activate spatial_computing_docs If the command line is now indicating the name of the environment in paranthesis, it means that the environment is activated. Similar to this ( spatial_computing_docs ) { your username } @ { your computer name } spatial_computing_project_template %","title":"Activate the Environment"},{"location":"documenting/instructions/#run-the-local-server","text":"Now that the environment is activated, we need to run the local server to be able to see the result of changes in the local version of the documentation website. For that, run the following command: mkdocs serve After running this command, if the server has started to work successfully, you should see the following line in the command line: INFO - Serving on http://127.0.0.1:8000 This means that the server is accessible at http://127.0.0.1:8000 . If you open your browser and go this link you should see a local version of the site.","title":"Run the Local Server"},{"location":"documenting/instructions/#writing-your-documentation","text":"In the documenting process you need to head to the docs folder and edit the .md (markdown) files, since the website is build from these files. In the root of this project, you can edit the configurations of your project in mkdocs.yml file: Adding o removing pages Add markdown extensions . Some of the useful extensions: arithmatex for writing mathematics highlight for code highlighting Customizing the looks of your documentation Adding MkDocs Plugins , such as: mknotebooks for including python notebooks in the documentations","title":"Writing Your Documentation"},{"location":"documenting/instructions/#finish-work-on-documentation","text":"","title":"Finish Work on Documentation"},{"location":"documenting/instructions/#server-shut-down","text":"To shutdown the server, you need to press Ctrl + C in the command line. The following should appear in the command line: INFO - Shutting down...","title":"Server Shut Down"},{"location":"documenting/instructions/#deactivate-environment","text":"After shutting down your server the command line is back to the normal state and you can run commands again. To deactivate your environment you need to run the following command: conda deactivate","title":"Deactivate Environment"},{"location":"documenting/instructions/#deployment-of-the-documentation-site","text":"","title":"Deployment of the Documentation Site"},{"location":"documenting/instructions/#build-and-deploy","text":"to deploy your documentation website, you need to run the following command in the root of this repository: mkdocs gh-deploy This command will create a new branch in your repository called gh-pages and build your site in it. It will then push the new branch to your remote repository automatically. It will also create a site folder in your root directory containing all of your site files. Since this folder is added .gitignore file, it won't be committed or pushed to the remote repository.","title":"Build and Deploy"},{"location":"documenting/instructions/#setup-github-pages","text":"For the first time, you need to configure the GitHub Pages service on your GitHub repository so it wil automatically build your documentation website whenever you deploy your site. To do this: Go to your repository setting, got GitHub Pages section, select gh-pages branch, select /(root) location, click on the save button. The setting page will refresh, and now if you go to the address that is provided at the GitHub Pages section, Wola, here is your documentation!","title":"Setup GitHub Pages"},{"location":"index/bibliography/","text":"Bibliography Here you should cite all references and materials that you have used in your project. This is in addition to citation in the documentation itself.","title":"Bibliography"},{"location":"index/bibliography/#bibliography","text":"Here you should cite all references and materials that you have used in your project. This is in addition to citation in the documentation itself.","title":"Bibliography"},{"location":"index/figures/","text":"Figures Here you should include all of your figures and links to the pages that they have been used in. You can embed your only videos like this:","title":"Figures"},{"location":"index/figures/#figures","text":"Here you should include all of your figures and links to the pages that they have been used in. You can embed your only videos like this:","title":"Figures"},{"location":"index/presentations/","text":"Presentations Here you should embed your poster and presentations. Here is an example:","title":"Presentations"},{"location":"index/presentations/#presentations","text":"Here you should embed your poster and presentations. Here is an example:","title":"Presentations"},{"location":"index/scripts/","text":"Scripts Here you should include all of your scripts whether they are text, python notebook or procedural scripts. You should also include link to the link to relevant location in the main pages, description, explanatory materials such as pseudo code or flowcharts, and visualizations if it is applicable. If necessary this page can be broken down to multiple pages. Here is an example of how to include your scripts: edges = [] for cell_neigh in cell_neighbors : cell = cell_neigh [ 0 ] for neigh in cell_neigh [ 1 :]: if neigh != - 1 and neigh > cell : edges . append (( cell , neigh ))","title":"Scripts"},{"location":"index/scripts/#scripts","text":"Here you should include all of your scripts whether they are text, python notebook or procedural scripts. You should also include link to the link to relevant location in the main pages, description, explanatory materials such as pseudo code or flowcharts, and visualizations if it is applicable. If necessary this page can be broken down to multiple pages. Here is an example of how to include your scripts: edges = [] for cell_neigh in cell_neighbors : cell = cell_neigh [ 0 ] for neigh in cell_neigh [ 1 :]: if neigh != - 1 and neigh > cell : edges . append (( cell , neigh ))","title":"Scripts"}]}